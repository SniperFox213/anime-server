"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RconConnection = exports.DEFAULT_RCON_CONNECTION_CONFIG = void 0;
const events_1 = __importDefault(require("events"));
const net_1 = __importDefault(require("net"));
const lodash_defaultsdeep_1 = __importDefault(require("lodash.defaultsdeep"));
exports.DEFAULT_RCON_CONNECTION_CONFIG = {
    host: 'localhost',
    port: 25575,
    password: 'password',
    buffer: 200,
};
class RconConnection extends events_1.default {
    constructor(config = {}) {
        super();
        this.authenticated = false;
        this.queue = [];
        this.promises = {};
        this.execId = RequestPacketId.Exec;
        this.config = lodash_defaultsdeep_1.default(config, { rconConnection: exports.DEFAULT_RCON_CONNECTION_CONFIG });
        this.tick();
    }
    connect(retry = true) {
        this.connection = net_1.default.connect({
            host: this.config.rconConnection.host,
            port: this.config.rconConnection.port,
        }, () => {
            var _a;
            this.listen();
            (_a = this.connection) === null || _a === void 0 ? void 0 : _a.write(encode(RequestPacketType.Auth, RequestPacketId.Auth, this.config.rconConnection.password));
        });
        this.connection.on('error', error => {
            if (retry && error.code === 'ECONNREFUSED') {
                console.log('Unable to connect, retrying...');
                setTimeout(() => this.connect(retry), 1000);
            }
            else {
                console.error(error.message);
            }
        });
    }
    disconnect() {
        var _a;
        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.destroy();
        this.connection = undefined;
        this.authenticated = false;
        this.queue = [];
        this.promises = {};
        this.emit('disconnected');
    }
    send(message) {
        return new Promise(resolve => {
            this.queue.push([message, resolve]);
        });
    }
    listen() {
        var _a;
        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.on('data', chunk => {
            var _a, _b;
            const packet = decode(chunk);
            if (packet.type === ResponsePacketType.Auth && packet.id === RequestPacketId.Auth) {
                this.authenticated = true;
                this.emit('connected');
            }
            else if (packet.type === ResponsePacketType.Exec) {
                (_b = (_a = this.promises)[packet.id]) === null || _b === void 0 ? void 0 : _b.call(_a, packet.body);
            }
            else {
                console.log('Unknown Packet Type:', packet);
            }
        });
    }
    tick() {
        if (this.connection && this.authenticated && this.queue.length) {
            const [message, promise] = this.queue.shift();
            const execId = this.getNextExecId();
            this.promises[execId] = promise;
            this.connection.write(encode(RequestPacketType.Exec, execId, message));
        }
        setTimeout(() => this.tick(), this.config.rconConnection.buffer);
    }
    getNextExecId() {
        return (this.execId += 1);
    }
}
exports.RconConnection = RconConnection;
var RequestPacketType;
(function (RequestPacketType) {
    RequestPacketType[RequestPacketType["Auth"] = 3] = "Auth";
    RequestPacketType[RequestPacketType["Exec"] = 2] = "Exec";
})(RequestPacketType || (RequestPacketType = {}));
var RequestPacketId;
(function (RequestPacketId) {
    RequestPacketId[RequestPacketId["Auth"] = 291] = "Auth";
    RequestPacketId[RequestPacketId["Exec"] = 801] = "Exec";
})(RequestPacketId || (RequestPacketId = {}));
var ResponsePacketType;
(function (ResponsePacketType) {
    ResponsePacketType[ResponsePacketType["Auth"] = 2] = "Auth";
    ResponsePacketType[ResponsePacketType["Exec"] = 0] = "Exec";
})(ResponsePacketType || (ResponsePacketType = {}));
function encode(type, id, body) {
    const size = Buffer.byteLength(body) + 14;
    const buffer = Buffer.alloc(size);
    buffer.writeInt32LE(size - 4, 0);
    buffer.writeInt32LE(id, 4);
    buffer.writeInt32LE(type, 8);
    buffer.write(body, 12, size - 2);
    buffer.writeInt16LE(0, size - 2);
    return buffer;
}
function decode(chunk) {
    const buffer = Buffer.from(chunk);
    return {
        size: buffer.readInt32LE(0),
        id: buffer.readInt32LE(4),
        type: buffer.readInt32LE(8),
        body: buffer.toString('utf8', 12, buffer.length - 2),
    };
}
//# sourceMappingURL=RconConnection.js.map